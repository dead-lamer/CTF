Сразу переходим к бинарнику и дизасемблируем его. 

![Интерфейс](https://github.com/dead-lamer/CTF/blob/main/writeup_pics/FlagCasinoHTB1.jpg)
![Код](https://github.com/dead-lamer/CTF/blob/main/writeup_pics/FlagCasinoHTB2.jpg)

Перед собой видим программу, которая выводит на экран баннер, а затем считывает 29 char символов. Каждый из них она использует как seed для функции rand(), а затем сравнивает результат вызова этой функции с эталоном, записанным в секции данных (массив check).
После ввода правильной последовательности, программа не выводит ничего кроме сообщения о том, что баланс казино опустел до 0. Следовательно понимаем, что для того, чтобы решить задачу, нужно ввести правильный флаг. В качестве проверки введем HTB, первые три байта прошли проверку, а значит мы на верном пути.

![Проверка](https://github.com/dead-lamer/CTF/blob/main/writeup_pics/FlagCasinoHTB3.jpg)

Функция rand() является псевдослучайной. Из-за чего мы точно знаем, что при первом вызове функции rand() для seed = x, мы будем получать один и тот же результат.
План для решения задачи невероятно прост:
1) каждому char символу будем сопоставлять результат работы функции rand(), где в качестве seed будем использовать этот же char
2) теперь будем читать секцию данных нашей программы и смотреть, какой символ надо ввести, чтобы получить то значение, которое необходимо (а именно массив check). Так мы соберем наш флаг побайтово

Напишем программу на Python:

```python
import ctypes 
libc ctypes.CDLL('libc.so.6')

arr = {}

for i in range(255): # 0 - 254
    libc.srand(i)
    arr[libc.rand()] = chr(i)

flag = ""
from pwn import *

e = ELF("./casino", checksec = False)
for j in range(29):
    val = e.u32(e.sym["check"] + j * 4) # offset
    flag += arr[val]
print(flag)
```

После этого на экран будет выведен флаг.
